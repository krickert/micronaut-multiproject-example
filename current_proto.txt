CODE LISTING FOR ./yappy-models/protobuf-models/src/main/proto/yappy_service_registration.proto





syntax = "proto3";

package com.krickert.yappy.registration.api;

// Consider standardizing your Java package options across all Yappy protos
option java_package = "com.krickert.yappy.registration.api";
option java_multiple_files = true;
option java_outer_classname = "YappyModuleRegistrationProto"; // Or similar

// Service definition for modules to register with the Yappy platform
service YappyModuleRegistrationService {
  // Allows a module instance to register itself with the Yappy platform.
  // The platform will then handle the actual registration with Consul.
  rpc RegisterModule (RegisterModuleRequest) returns (RegisterModuleResponse);

  // Future: Allows a module instance to gracefully deregister itself.
  // rpc DeregisterModule (DeregisterModuleRequest) returns (DeregisterModuleResponse);

  // Future: Allows a module instance to update its status or send heartbeats if using TTL checks.
  // rpc UpdateModuleStatus (UpdateModuleStatusRequest) returns (UpdateModuleStatusResponse);
}

// Enum for specifying the type of health check the module exposes.
enum HealthCheckType {
  HEALTH_CHECK_TYPE_UNKNOWN = 0; // Default, should not be used
  HTTP = 1;                      // Standard HTTP GET endpoint
  GRPC = 2;                      // Standard gRPC health check (grpc.health.v1.Health)
  TCP = 3;                       // Simple TCP connect check
  TTL = 4;                       // Time-To-Live; module must send heartbeats via UpdateModuleStatus
}

// Request message for registering a module instance.
message RegisterModuleRequest {
  // The unique identifier for the *type* of this module.
  // This ID links the running instance to its definition in PipelineModuleConfiguration.
  // Example: "echo-processor-v1", "opennlp-chunker-v2.1"
  string implementation_id = 1;

  // The desired service name for this specific instance in Consul.
  // Can be unique per instance (e.g., "echo-instance-abc12") or a common name
  // if multiple instances of the same implementationId are load-balanced.
  // If multiple instances share a name, instance_id_hint becomes more important.
  string instance_service_name = 2;

  // The network-accessible host or IP address of this module instance.
  string host = 3;

  // The port number on which this module instance's gRPC server is listening.
  int32 port = 4;

  // The type of health check this module instance supports.
  HealthCheckType health_check_type = 5;

  // The endpoint for the health check.
  // - For HTTP: Path (e.g., "/health/ready")
  // - For GRPC: Fully qualified service/method (e.g., "grpc.health.v1.Health/Check")
  // - For TCP: Can be empty (host/port from above are used)
  // - For TTL: Not applicable here, interval defined by registration service
  string health_check_endpoint = 6;

  // The JSON string representation of this module instance's custom configuration.
  // The Yappy Registration Service will canonicalize this JSON and calculate its digest.
  string instance_custom_config_json = 7; // MODIFIED: Was config_digest

  // Optional: The software version of this module instance (e.g., "1.0.2").
  optional string module_software_version = 8;

  // Optional: A hint for generating a unique instance ID in Consul.
  // If not provided, the Registration Service will generate one.
  // Useful if the module instance already has a stable unique ID (e.g., K8s pod name).
  optional string instance_id_hint = 9;

  // Optional: Any additional tags this module instance suggests for its Consul registration.
  // The Registration Service may add its own standard tags as well.
  map<string, string> additional_tags = 10;
}

// Response message for the RegisterModule RPC.
message RegisterModuleResponse {
  // Indicates if the registration request was successfully processed by the
  // Yappy Registration Service and forwarded to Consul.
  bool success = 1;

  // A human-readable message indicating the outcome or any errors.
  string message = 2;

  // The unique service ID assigned to this module instance by Consul
  // (as registered by the Yappy Registration Service).
  // This can be useful for the module if it needs to perform self-deregistration later.
  string registered_service_id = 3;

  // The configuration digest calculated by the Yappy Registration Service based on
  // the provided instance_custom_config_json. This is the digest that will be
  // stored in Consul tags and used for consistency checks.
  string calculated_config_digest = 4; // NEW

  // Optional: The canonical JSON string (Base64 encoded) that the Yappy Registration
  // Service used to calculate the digest. Useful for debugging and verification by the module.
  optional string canonical_config_json_base64 = 5; // NEW (Optional)
}

// Future placeholder messages for DeregisterModule and UpdateModuleStatus
// message DeregisterModuleRequest {
//   string registered_service_id = 1; // ID obtained from RegisterModuleResponse
// }
// message DeregisterModuleResponse {
//   bool success = 1;
//   string message = 2;
// }
//
// message UpdateModuleStatusRequest {
//   string registered_service_id = 1;
//   // Could include current load, specific health status details, etc.
//   // For TTL checks, this would be the heartbeat.
// }
// message UpdateModuleStatusResponse {
//   bool acknowledged = 1;
// }

END OF ./yappy-models/protobuf-models/src/main/proto/yappy_service_registration.proto


CODE LISTING FOR ./yappy-models/protobuf-models/src/main/proto/engine_service.proto





syntax = "proto3";

package com.krickert.search.engine;

option java_multiple_files = true;
option java_package = "com.krickert.search.engine";
option java_outer_classname = "EngineServiceProto";

import "yappy_core_types.proto"; // This should define com.krickert.search.model.PipeDoc
import "google/protobuf/empty.proto";

// --- Messages for the Connector RPC ---
message ConnectorRequest {
  // REQUIRED. An identifier for the connector or data source submitting this data.
  // The engine will use this ID to look up the pre-configured target pipeline and initial step.
  // Example: "s3-landing-bucket-connector", "customer-api-ingest-v1".
  string source_identifier = 1;

  // REQUIRED. The initial document data to be processed.
  com.krickert.search.model.PipeDoc document = 2;

  // Optional. Key-value parameters to be included in the PipeStream's context_params.
  // Useful for passing global run context like tenant_id, user_id, correlation_id from the connector.
  map<string, string> initial_context_params = 3;

  // Optional. If the connector wants to suggest a stream_id.
  // If empty, the engine MUST generate a unique one.
  // If provided, the engine MAY use it or generate its own if there's a conflict or policy.
  optional string suggested_stream_id = 4;
}

message ConnectorResponse {
  // The unique stream_id assigned by the engine to this ingestion flow.
  // This allows the connector to correlate this ingestion with the pipeline execution.
  string stream_id = 1;

  // Indicates if the ingestion request was successfully accepted and queued by the engine.
  // This does not guarantee the pipeline itself will succeed, only that ingestion was accepted.
  bool accepted = 2;

  // Optional message, e.g., "Ingestion accepted for stream ID [stream_id], targeting configured pipeline."
  string message = 3;
}


// PipeStreamEngine service orchestrates pipeline execution.
service PipeStreamEngine {
  // --- Existing RPCs (can be kept for specific internal/advanced use cases or deprecated over time) ---
  // --- NOTE: a sink has the same signature - the engine controls the outgoing routing, if it's a sink implementation then that will be noted in the step
  rpc testPipeStream(com.krickert.search.model.PipeStream) returns (com.krickert.search.model.PipeStream);
  rpc processPipeAsync(com.krickert.search.model.PipeStream) returns (google.protobuf.Empty);

  // Ingests new data (as a PipeDoc identified by a source_identifier) into the system
  // to start a pipeline asynchronously. The engine will:
  // 1. Use source_identifier to look up the configured target pipeline and initial step.
  // 2. Create the PipeStream, generate a stream_id.
  // 3. Initiate the pipeline.
  rpc processConnectorDoc(ConnectorRequest) returns (ConnectorResponse);
}



END OF ./yappy-models/protobuf-models/src/main/proto/engine_service.proto


CODE LISTING FOR ./yappy-models/protobuf-models/src/main/proto/yappy_core_types.proto





syntax = "proto3";

package com.krickert.search.model;

option java_multiple_files = true;
option java_package = "com.krickert.search.model";
option java_outer_classname = "YappyCoreTypesProto";

import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";

// --- Core Document Representation ---

// Represents a single named vector embedding, typically for a whole document or a non-chunk segment.
message Embedding {
  // Optional: Name or identifier for the model that generated this embedding.
  optional string model_id = 1;
  repeated float vector = 2;        // The vector representation.
}

// Represents the text content and vector embedding for a single chunk.
message ChunkEmbedding {
  string text_content = 1;        // The actual text content of the chunk.
  repeated float vector = 2;       // The vector embedding for this chunk's text.
  optional string chunk_id = 3;     // Unique identifier for this chunk.
  optional int32 original_char_start_offset = 4; // Optional: start offset in original document.
  optional int32 original_char_end_offset = 5;   // Optional: end offset in original document.
  optional string chunk_group_id = 6; // Optional: Identifier for a group of related chunks.
  optional string chunk_config_id = 7; // Optional: Identifier for the chunking configuration used.
}

// Represents a single semantic chunk of text with its embedding.
message SemanticChunk {
  string chunk_id = 1;              // Unique identifier for this specific chunk within its parent SemanticProcessingResult.
  int64 chunk_number = 2;           // Sequential number of the chunk within its parent SemanticProcessingResult.
  ChunkEmbedding embedding_info = 3; // The text and embedding for this chunk.
  map<string, google.protobuf.Value> metadata = 4; // Optional metadata specific to this chunk (e.g., original page number, section).
}

// Represents the complete result of one specific semantic chunking and/or embedding process
// applied to a field of a PipeDoc. A PipeDoc can store multiple such results.
message SemanticProcessingResult {
  string result_id = 1;               // Unique ID for this specific result set (e.g., UUID for this instance of processing).
  string source_field_name = 2;       // Name of the field within the parent PipeDoc that was processed (e.g., "body", "title").

  string chunk_config_id = 3;         // Identifier for the chunking configuration used (e.g., "sentence_splitter_v1", "token_chunker_512_overlap_50").
  string embedding_config_id = 4;     // Identifier for the embedding model/configuration used (e.g., "ada_002_v1", "minilm_l6_v2").

  // A generated identifier/name for this set of (chunked and) embedded data.
  // Useful as a prefix for field names in a search index or for display/selection.
  // Example: "body_chunks_ada_002", "title_sentences_minilm"
  // This would typically be generated by the pipeline step that produces this result.
  optional string result_set_name = 5;

  repeated SemanticChunk chunks = 6;    // List of semantic chunks with their embeddings produced by this specific configuration.
  map<string, google.protobuf.Value> metadata = 7; // Metadata about this specific processing run (e.g., model version details, execution time).
}

message PipeDoc {
  string id = 1;                          // REQUIRED. Unique identifier for the document.
  optional string source_uri = 2;         // Optional. URI where the original document came from (e.g., s3://, http://).
  optional string source_mime_type = 3;   // Optional. Original MIME type of the content that *led* to this PipeDoc (e.g., "application/pdf").

  optional string title = 4;
  optional string body = 5;               // Main textual content, often the target for chunking/embedding.
  repeated string keywords = 6;
  optional string document_type = 7;      // e.g., "article", "product", "email".
  optional string revision_id = 8;        // Optional. Version identifier for the source content.

  optional google.protobuf.Timestamp creation_date = 9;   // When the source document was created or first seen.
  optional google.protobuf.Timestamp last_modified_date = 10; // When the source document content was last modified.
  optional google.protobuf.Timestamp processed_date = 11;   // When this PipeDoc representation was last significantly processed/updated by the pipeline.

  optional google.protobuf.Struct custom_data = 12; // For flexible, non-standard structured data related to the document.

  // Holds results from potentially multiple, different chunking and/or embedding processes applied to this document.
  repeated SemanticProcessingResult semantic_results = 13;

  // Map for storing other named embeddings (e.g., whole document embeddings, image embeddings).
  // Key could be a descriptive name like "full_document_ada_002_embedding" or "header_image_clip_embedding".
  map<string, Embedding> named_embeddings = 14;

  optional Blob blob = 15;
}

// --- Binary Data Handling ---

message Blob {
  optional string blob_id = 1;            // Optional: Unique identifier for this blob (e.g., hash of content or UUID).
  bytes data = 2;                     // REQUIRED. The raw binary content.
  optional string mime_type = 3;        // MIME type of the content in 'data' (e.g., "application/pdf", "image/jpeg").
  optional string filename = 4;           // Optional: Original filename associated with this binary data.
  optional string encoding = 5;           // Optional: Character encoding if 'data' represents text (e.g., "UTF-8").
  map<string, string> metadata = 6;     // Optional: Additional key-value metadata specific to this blob.
}

// --- Error and History Structures ---

// Captures input state for a failed step attempt, used within ErrorData.
message FailedStepInputState {
  // The PipeDoc as it was *before* the failed step was attempted.
  optional PipeDoc doc_state = 1;
  // The Blob as it was *before* the failed step was attempted.
  optional Blob blob_state = 2;
  // The custom_json_config (as Struct) provided to the failed step.
  optional google.protobuf.Struct custom_config_struct = 3;
  // The config_params provided to the failed step.
  map<string, string> config_params = 4;
}

message ErrorData {
  string error_message = 1;               // REQUIRED. Human-readable description of the error.
  optional string error_code = 2;         // Optional. Machine-readable error code (e.g., "CONFIG_VALIDATION_ERROR", "TIMEOUT_ERROR").
  optional string technical_details = 3;    // Optional. Snippet of stack trace, detailed diagnostic information.
  string originating_step_name = 4;     // REQUIRED. The 'stepName' of the PipelineStepConfig where the error originated or was detected.
  optional string attempted_target_step_name = 5; // Optional. If error occurred during an attempt to route or dispatch to a *next* step.
  optional FailedStepInputState input_state_at_failure = 6; // Optional. State of data/config when the step failed, for reproducibility.
  google.protobuf.Timestamp timestamp = 7;  // REQUIRED. When the error occurred or was logged.
}

message StepExecutionRecord {
  int64 hop_number = 1;                       // Sequential hop number for this step in the stream.
  string step_name = 2;                        // 'stepName' of the PipelineStepConfig that was executed.
  optional string service_instance_id = 3;      // Optional. Identifier of the specific service instance/pod that executed the step.
  google.protobuf.Timestamp start_time = 4;     // When step processing began.
  google.protobuf.Timestamp end_time = 5;       // When step processing ended.
  // Expected statuses: "SUCCESS", "FAILURE", "SKIPPED" (add more as needed, e.g., "RETRYING")
  string status = 6;                           // REQUIRED. Outcome of the step.
  repeated string processor_logs = 7;           // Logs specifically from the processor for this step's execution.
  optional ErrorData error_info = 8;            // Specific error from *this step* if status is "FAILURE".
  optional string attempted_target_step_name = 9; // Optional. If status is "DISPATCH_FAILURE", this is the

}

// --- Pipeline Execution State ---

message PipeStream {
  string stream_id = 1;                       // REQUIRED. Unique ID for this execution flow instance.
  PipeDoc document = 2;                       // REQUIRED (can be an empty message initially). The primary document being processed.
  string current_pipeline_name = 3;           // REQUIRED. Name of the PipelineConfig being executed.

  // REQUIRED by the sender (Engine or Kafka Framework).
  // The 'stepName' (key from PipelineConfig.steps map) of the PipelineStepConfig
  // that is the intended next recipient/processor of this PipeStream.
  string target_step_name = 4;

  int64 current_hop_number = 5;               // For logging/tracing; incremented by the engine/framework *before* dispatching to
  // target_step_name.
  repeated StepExecutionRecord history = 6;     // History of executed steps in this stream.
  optional ErrorData stream_error_data = 7;     // Holds the first critical error that puts the *entire stream* into a general error
  // state, possibly halting further processing unless handled by an error pipeline.
  map<string, string> context_params = 8;     // Optional. Key-value parameters for the entire run's context (e.g., tenant_id, user_id,
  // correlation_id).
}


END OF ./yappy-models/protobuf-models/src/main/proto/yappy_core_types.proto


CODE LISTING FOR ./yappy-models/protobuf-models/src/main/proto/pipe_step_processor_service.proto





syntax = "proto3";

// Assuming your yappy_core_types.proto is in com.krickert.search.model
// and generates Java classes into com.krickert.search.model
package com.krickert.search.model; // Or com.krickert.search.sdk if that's where PipeStepProcessor lives

option java_package = "com.krickert.search.sdk"; // Or com.krickert.search.model - for generated Java
option java_multiple_files = true;
option java_outer_classname = "PipeStepProcessorServiceProto";

// Import definitions from your core types file
import "yappy_core_types.proto"; // This file should contain PipeDoc, Blob, StepExecutionRecord, ErrorData etc.
import "google/protobuf/struct.proto"; // For custom_json_config

// Service definition for a pipeline step processor.
// This interface is implemented by developer-created gRPC modules/services.
service PipeStepProcessor {
  // Processes a document according to the step's configuration and logic.
  rpc ProcessData(ProcessRequest) returns (ProcessResponse);
}

// Contains metadata provided by the pipeline engine for context.
// This data is generally for informational purposes, logging, tracing, or advanced conditional logic.
message ServiceMetadata {
  // The 'pipelineName' from PipelineConfig providing context for this call.
  string pipeline_name = 1;

  // The 'stepName' from PipelineStepConfig that this gRPC service instance is currently executing as.
  string pipe_step_name = 2;

  // Unique ID for the entire execution flow (equivalent to PipeStream.stream_id).
  string stream_id = 3;

  // The current hop number in the pipeline for this step's execution.
  int64 current_hop_number = 4;

  // History of previously executed steps in this stream.
  // Note: This can be large. Modules should use it judiciously.
  repeated StepExecutionRecord history = 5;

  // If the overall stream was previously marked with a critical error.
  // Modules might use this to alter behavior (e.g., skip processing if stream is already failed).
  optional ErrorData stream_error_data = 6;

  // Key-value parameters for the entire run's context (e.g., tenant_id, user_id, correlation_id).
  // Equivalent to PipeStream.context_params.
  map<string, string> context_params = 7;
}

// Contains configuration specific to this instance of the pipeline step.
message ProcessConfiguration {
  // The specific, validated custom JSON configuration for this step,
  // converted by the engine from PipelineStepConfig.customConfig.jsonConfig.
  google.protobuf.Struct custom_json_config = 1;

  // The 'configParams' map from PipelineStepConfig for this step.
  map<string, string> config_params = 2;
}

// Request message for the ProcessData RPC.
message ProcessRequest {
  // The primary document data to be processed.
  // The Blob is now expected to be within PipeDoc if used.
  PipeDoc document = 1;

  // Configuration for this specific processing step.
  ProcessConfiguration config = 2;

  // Engine-provided metadata for context and observability.
  ServiceMetadata metadata = 3;
}

// Response message for the ProcessData RPC.
// This is returned by the gRPC Service Implementation back to the engine.
// This message can remain largely the same as your existing ProcessResponse.
message ProcessResponse {
  // Outcome: True if this step's processing was successful, false otherwise.
  bool success = 1;

  // Output Data: The modified or newly created PipeDoc.
  // either remains unchanged or that this step does not modify the PipeDoc directly.
  // The Blob is part of the PipeDoc.
  optional PipeDoc output_doc = 2;

  // Error Details: Structured error information from *this processor* if success is false.
  // This is for errors specific to the processor's execution logic.
  optional google.protobuf.Struct error_details = 3; // Using Struct for flexibility.

  // Logging: Logs or summary information generated by this processor step.
  repeated string processor_logs = 4;
}

END OF ./yappy-models/protobuf-models/src/main/proto/pipe_step_processor_service.proto


CODE LISTING FOR ./yappy-models/protobuf-models/src/main/proto/pipeline_schema_registry.proto





syntax = "proto3";

package com.krickert.search.schema.registry;

option java_multiple_files = true;
option java_package = "com.krickert.search.schema.registry";
option java_outer_classname = "SchemaRegistryServiceProto";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

// Service for managing JSON schema definitions used by pipeline steps.
// These schemas define the expected structure for the 'custom_json_config'
// field within a PipelineStepConfig.
service SchemaRegistryService {
  // Registers a new JSON schema or updates an existing one.
  // The schema content itself is validated for being a valid JSON schema.
  // If a schema with the same schema_id already exists, it will be updated.
  rpc RegisterSchema(RegisterSchemaRequest) returns (RegisterSchemaResponse);

  // Retrieves a specific JSON schema by its ID.
  rpc GetSchema(GetSchemaRequest) returns (GetSchemaResponse);

  // Deletes a JSON schema by its ID.
  rpc DeleteSchema(DeleteSchemaRequest) returns (DeleteSchemaResponse);

  // Lists all registered JSON schemas, with optional filtering.
  rpc ListSchemas(ListSchemasRequest) returns (ListSchemasResponse); // <--- Description updated

  // Validates the provided JSON schema content without registering it.
  // This can be used to check schema correctness before attempting registration.
  rpc ValidateSchemaContent(ValidateSchemaContentRequest) returns (ValidateSchemaContentResponse);
}

// Contains the definition and metadata of a JSON schema.
message SchemaInfo {
  // REQUIRED. A unique identifier for this schema (e.g., "my-processor-config-schema-v1").
  // This ID is used in PipelineStepConfig.customConfigSchemaId to reference this schema.
  string schema_id = 1;

  // REQUIRED. The actual JSON schema content as a string.
  string schema_content = 2;

  // Optional. A human-readable description of the schema.
  optional string description = 3;

  // Timestamp of when this schema was first created.
  google.protobuf.Timestamp created_at = 4;

  // Timestamp of when this schema was last updated.
  google.protobuf.Timestamp updated_at = 5;

  // Optional. Additional metadata for the schema (e.g., author, version tags).
  map<string, string> metadata = 6;

  // Reserved for future use, e.g., "JSON_SCHEMA", "AVRO". Currently implies "JSON_SCHEMA".
  // string schema_type = 7;
}

// Request to register or update a JSON schema.
message RegisterSchemaRequest {
  // REQUIRED. The unique identifier for the schema.
  string schema_id = 1;

  // REQUIRED. The JSON schema content as a string.
  string schema_content = 2;

  // Optional. A human-readable description.
  optional string description = 3;

  // Optional. Additional metadata.
  map<string, string> metadata = 4;
}

// Response from a RegisterSchema operation.
message RegisterSchemaResponse {
  // The schema_id of the registered or updated schema.
  string schema_id = 1;

  // True if the schema was successfully validated and registered/updated.
  // False if validation of the schema_content itself failed.
  bool success = 2;

  // List of validation errors if success is false. Empty if successful.
  // These errors pertain to the validity of the schema_content as a JSON schema document.
  repeated string validation_errors = 3;

  // Timestamp of the registration or update.
  google.protobuf.Timestamp timestamp = 4;
}

// Request to retrieve a JSON schema.
message GetSchemaRequest {
  // REQUIRED. The unique identifier of the schema to retrieve.
  string schema_id = 1;
  // Optional: string version_id = 2; // If versioning per schema_id is implemented later.
}

// Response containing the retrieved JSON schema.
message GetSchemaResponse {
  // The requested schema information.
  // If not found, a gRPC NOT_FOUND error status will be returned.
  SchemaInfo schema_info = 1;
}

// Request to delete a JSON schema.
message DeleteSchemaRequest {
  // REQUIRED. The unique identifier of the schema to delete.
  string schema_id = 1;
  // Optional: string version_id = 2; // If versioning per schema_id is implemented later.
}

// Response from a DeleteSchema operation.
// Returns google.protobuf.Empty on successful deletion.
// Returns gRPC NOT_FOUND error status if schema_id does not exist.
message DeleteSchemaResponse {
  google.protobuf.Empty acknowledgement = 1;
}

// Request to list JSON schemas.
message ListSchemasRequest {
  // Optional. A filter to apply to schema_id (e.g., prefix match).
  optional string id_filter = 1;
  // page_size and page_token removed
}

// Response containing a list of JSON schemas.
message ListSchemasResponse {
  // A list of schema information objects.
  repeated SchemaInfo schemas = 1;
  // next_page_token removed
}

// Request to validate JSON schema content.
message ValidateSchemaContentRequest {
  // REQUIRED. The JSON schema content as a string to be validated.
  string schema_content = 1;
}

// Response from a ValidateSchemaContent operation.
message ValidateSchemaContentResponse {
  // True if the provided schema_content is a valid JSON schema document.
  bool is_valid = 1;

  // List of validation errors if is_valid is false. Empty if valid.
  repeated string validation_errors = 2;
}

END OF ./yappy-models/protobuf-models/src/main/proto/pipeline_schema_registry.proto


