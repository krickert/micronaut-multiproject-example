syntax = "proto3";

package com.example.pipeline.streaming; // Adjust package name

// Import definitions from your existing pipeline and MCP protos
import "pipeline_models.proto"; // Contains PipeDoc, Route, ErrorData etc.
import "mcp-api.proto"; // Contains McpResource, McpContext etc. (if needed for context)
import "google/protobuf/timestamp.proto";
import "google/rpc/status.proto";

option java_package = "com.example.pipeline.streaming.proto";
option java_outer_classname = "StreamingPipelineProto";
option java_multiple_files = true;

// --- Message Definitions ---

// Initial request to start a streaming pipeline execution.
message StartPipelineStreamRequest {
  // Unique identifier for this pipeline execution instance.
  string execution_id = 1;

  // Identifier for the pipeline definition to execute.
  string pipeline_id = 2;

  // The initial document to process.
  com.krickert.search.model.PipeDoc initial_doc = 3;

  // Initial configuration or parameters for this execution.
  map<string, string> initial_config = 4;

  // Optional: Context information (could reuse McpRequestContext if suitable).
  // com.example.mcp.McpRequestContext context = 5;
}

// Represents a message flowing through the pipeline stream.
// Can be sent from server to client (updates, results) or client to server (acks, controls).
message PipelineStreamMessage {
  // Correlates messages to a specific pipeline execution.
  string execution_id = 1;

  // Sequence number for ordering messages within the stream for a given execution.
  int64 sequence_number = 2;

  // Timestamp for the event represented by this message.
  google.protobuf.Timestamp timestamp = 3;

  // The actual content of the message.
  oneof payload {
    PipelineStepUpdate step_update = 4;       // Status update from a pipeline step.
    IntermediateResult intermediate_result = 5; // Output from an intermediate step.
    FinalResult final_result = 6;             // Final output of the pipeline.
    PipelineError pipeline_error = 7;         // Error encountered during execution.
    ClientAcknowledgement client_ack = 8;     // Client acknowledging receipt/processing.
    // Add other control messages as needed (e.g., pause, resume, cancel requests from client)
  }
}

// Details about the status of a specific step in the pipeline.
message PipelineStepUpdate {
  // Identifier for the pipeline step (e.g., service name, function name).
  string step_id = 1;

  // Status of the step (e.g., "STARTED", "PROCESSING", "COMPLETED", "FAILED").
  string status = 2;

  // Optional message providing more details about the status.
  string message = 3;
}

// Represents the output document from an intermediate step.
message IntermediateResult {
  // Identifier for the step that produced this result.
  string producing_step_id = 1;

  // The document produced by the step.
  com.krickert.search.model.PipeDoc output_doc = 2;

  // Optional: Routing information for the next step(s), if determined dynamically.
  repeated com.krickert.search.model.Route next_routes = 3;
}

// Represents the final output of the entire pipeline.
message FinalResult {
  // The final processed document.
  com.krickert.search.model.PipeDoc final_doc = 1;

  // Overall status of the pipeline execution (e.g., "SUCCESS", "PARTIAL_SUCCESS", "FAILURE").
  string overall_status = 2;
}

// Represents an error that occurred during pipeline execution.
message PipelineError {
  // Identifier for the step where the error occurred (if applicable).
  optional string failing_step_id = 1;

  // Structured error details.
  google.rpc.Status error_detail = 2;

  // Optional: The document state when the error occurred.
  optional com.krickert.search.model.PipeDoc error_doc_state = 3;
}

// Client acknowledging receipt or processing of a server message.
message ClientAcknowledgement {
  // Sequence number of the server message being acknowledged.
  int64 server_sequence_number_acked = 1;
}


// --- Service Definition ---

// Service definition for executing pipelines via bidirectional streaming.
service StreamingPipelineService {
  // Establishes a bidirectional stream to execute a pipeline.
  // Client sends an initial StartPipelineStreamRequest.
  // Server streams back PipelineStreamMessage updates (status, results, errors).
  // Client can optionally send back PipelineStreamMessage acknowledgements or control messages.
  rpc ExecutePipelineStream(stream PipelineStreamMessage) returns (stream PipelineStreamMessage);
}