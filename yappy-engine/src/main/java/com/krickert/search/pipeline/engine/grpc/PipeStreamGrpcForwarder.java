package com.krickert.search.pipeline.engine.grpc;

import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.protobuf.Timestamp;
import com.krickert.search.engine.PipeStreamEngineGrpc;
import com.krickert.search.model.ErrorData;
import com.krickert.search.model.PipeStream;
import com.krickert.search.pipeline.engine.exception.GrpcEngineException;
import com.krickert.search.pipeline.engine.kafka.KafkaForwarder;
import com.krickert.search.pipeline.grpc.client.GrpcChannelManager;
import io.grpc.ManagedChannel;
import jakarta.inject.Inject;
import jakarta.inject.Singleton;
import lombok.Builder;
import lombok.Getter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.ExecutorService; // Need an executor for the callback
import io.micronaut.scheduling.TaskExecutors; // Micronaut provides common executors
import jakarta.inject.Named; // To inject a specific executor

@Singleton
// @Getter is likely not needed on the class unless you have public fields you want Lombok to generate getters for.
// If RouteData is the only thing, its getters are generated by 'record'.
public class PipeStreamGrpcForwarder {
    private static final Logger log = LoggerFactory.getLogger(PipeStreamGrpcForwarder.class);

    private final GrpcChannelManager channelManager;
    private final ExecutorService executorService; // Executor for handling future callbacks
    private final KafkaForwarder kafkaForwarder;

    @Inject
    public PipeStreamGrpcForwarder(
            GrpcChannelManager channelManager,
            @Named(TaskExecutors.SCHEDULED) ExecutorService executorService, KafkaForwarder kafkaForwarder) { // Inject a suitable executor
        this.channelManager = channelManager;
        this.executorService = executorService;
        this.kafkaForwarder = kafkaForwarder;
    }

    /**
     * Forwards a PipeStream message to another gRPC engine instance asynchronously.
     * The target service is determined by the route's destination.
     *
     * @param pipeBuilder The PipeStream builder containing the message state.
     * @param route The routing information including target pipeline, step, and destination service name.
     */
    public void forwardToGrpc(PipeStream.Builder pipeBuilder, RouteData route) {
        // Input validation (optional but good practice)
        if (pipeBuilder == null || route == null || route.destination() == null || route.destination().isBlank()) {
            log.error("Attempted to forward null PipeStream or invalid route data.");
            // Depending on requirements, you might throw an exception here or handle it differently.
            return;
        }

        // Update the PipeStream state based on the route for the *next* hop
        pipeBuilder.setCurrentPipelineName(route.targetPipeline());
        pipeBuilder.setTargetStepName(route.nextTargetStep());
        // Assuming streamId is already set on the builder, but setting it again is harmless if idempotent
        pipeBuilder.setStreamId(route.streamId());
        PipeStream pipe = pipeBuilder.build();

        String targetService = route.destination();
        String streamId = pipe.getStreamId(); // Use the built pipe for streamId

        log.debug("Attempting to forward PipeStream (streamId: {}) via gRPC to service: {}, target step: {}",
                streamId, targetService, route.nextTargetStep());

        try {
            ManagedChannel channel = channelManager.getChannel(targetService);

            // Use a FutureStub for asynchronous calls
            PipeStreamEngineGrpc.PipeStreamEngineFutureStub stub = PipeStreamEngineGrpc.newFutureStub(channel);

            // Make the asynchronous call
            ListenableFuture<com.google.protobuf.Empty> future = stub.processPipeAsync(pipe);

            Futures.addCallback(future, new FutureCallback<com.google.protobuf.Empty>() {
                @Override
                public void onSuccess(com.google.protobuf.Empty result) {
                    log.info("Successfully forwarded PipeStream (streamId: {}) via gRPC to service: {}, intended next target step: {}",
                            streamId, targetService, route.nextTargetStep());
                }

                @Override
                public void onFailure(Throwable t) {
                    log.error("Failed to forward PipeStream (streamId: {}) via gRPC to service {}: {}",
                            streamId, targetService, t.getMessage(), t);

                    // --- DLQ Logic for gRPC Call Failure ---
                    PipeStream.Builder errorPipeBuilder = pipe.toBuilder(); // Start with the message we tried to send

                    ErrorData.Builder errorDataBuilder = ErrorData.newBuilder();
                    errorDataBuilder.setErrorMessage("gRPC forwarding failed to service: " + targetService + ". Reason: " + t.getMessage());
                    errorDataBuilder.setErrorCode("GRPC_FORWARDING_FAILURE"); // Define this constant elsewhere
                    errorDataBuilder.setTechnicalDetails("Exception: " + t.getClass().getName() + ". Target Service: " + targetService);

                    // Determining originating_step_name:
                    // This error occurs *after* a step in the current engine has completed and routing is attempted.
                    // The 'pipeToSend' object is the state *after* that last successful step.
                    // So, the originating step is the last one in its history.
                    if (!pipe.getHistoryList().isEmpty()) {
                        errorDataBuilder.setOriginatingStepName(pipe.getHistory(pipe.getHistoryCount() - 1).getStepName());
                    } else {
                        // Fallback if history is empty (e.g., connector directly forwarding, though less likely for inter-engine)
                        errorDataBuilder.setOriginatingStepName("UnknownOrInitialStep");
                    }

                    errorDataBuilder.setAttemptedTargetStepName(route.nextTargetStep()); // The step in the remote engine we aimed for
                    errorDataBuilder.setTimestamp(Timestamp.newBuilder().setSeconds(System.currentTimeMillis() / 1000).build()); // Current time

                    // input_state_at_failure is optional. For a forwarding failure, the 'pipeToSend'
                    // itself represents the state. You could choose to populate parts of FailedStepInputState
                    // if you consider the forwarding action a conceptual step, but for now,
                    // the main ErrorData fields capture the forwarding context well.

                    errorPipeBuilder.setStreamErrorData(errorDataBuilder.build());
                    PipeStream errorPipeStream = errorPipeBuilder.build();

                    log.warn("Sending failed PipeStream (streamId: {}) to DLQ due to gRPC forwarding failure to service: {}", streamId, targetService);
                    kafkaForwarder.forwardToErrorTopic(errorPipeStream, targetService) // targetService can be the 'originalTopic'
                            .whenComplete((metadata, ex) -> {
                                if (ex != null) {
                                    log.error("CRITICAL: Failed to send message (streamId: {}) to DLQ for targetService {}: {}",
                                            streamId, targetService, ex.getMessage(), ex);
                                } else {
                                    log.info("Message (streamId: {}) successfully sent to DLQ for targetService {}. DLQ Topic: error-{}, Partition: {}, Offset: {}",
                                            streamId, targetService, targetService, metadata.partition(), metadata.offset());
                                }
                            });
                    // --- End DLQ Logic ---
                }
            }, executorService);


        } catch (GrpcEngineException e) {
            // This catch block handles exceptions from channelManager.getChannel()
            // (e.g., configuration errors, service not found after discovery attempts).
            log.error("Failed to get gRPC channel for service {}: {}. StreamId: {}", targetService, e.getMessage(), streamId, e);

            // COMMENT: Decide on error handling strategy for *channel acquisition failure*.
            // This is different from a call failure (handled in the callback).
            // Options for the future:
            // 1. Log and swallow (if fire-and-forget is absolute - current approach).
            // 2. Log and mark stream as error (if state management allows).
            // 3. Log and send to dead-letter queue (deferred for now).
            // 4. Rethrow a new exception if the caller *must* know immediately (e.g., in testPipeStream).
            // Given the async nature of processPipeAsync, rethrowing here might be inconsistent
            // with the fire-and-forget model for the call itself. Logging and perhaps
            // marking the stream (if possible) or dead-lettering seems more appropriate for async processing.
            // For now, we are only logging.
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the setup
            log.error("Unexpected error during gRPC forwarding setup for streamId {}: {}. TargetService: {}", streamId, e.getMessage(), targetService, e);
            // COMMENT: Handle similarly to GrpcEngineException. For now, only logging.
            // Future considerations: DLQ, marking stream as error.
        }
    }

    // RouteData record definition remains the same
    @Builder
    public record RouteData(
            String targetPipeline,
            String nextTargetStep,
            String destination, // This is the service name for channelManager
            String streamId
    ) {
    }
}