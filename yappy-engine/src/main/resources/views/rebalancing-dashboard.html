<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kafka Rebalancing Dashboard - Engine ${engineId}</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 30px;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .card h3 {
            margin-top: 0;
            color: #34495e;
            font-size: 18px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
        }
        
        .metric-value {
            font-weight: bold;
            color: #3498db;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 30px;
        }
        
        .event-log {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-height: 400px;
            overflow-y: auto;
        }
        
        .event {
            padding: 10px;
            margin: 5px 0;
            border-left: 3px solid #3498db;
            background: #ecf0f1;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .event.gain {
            border-left-color: #27ae60;
        }
        
        .event.loss {
            border-left-color: #e74c3c;
        }
        
        .status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .status.connected {
            background: #27ae60;
            color: white;
        }
        
        .status.disconnected {
            background: #e74c3c;
            color: white;
        }
        
        .partition-map {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            gap: 5px;
            margin-top: 20px;
        }
        
        .partition {
            background: #3498db;
            color: white;
            text-align: center;
            padding: 5px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .partition.mine {
            background: #27ae60;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .updating {
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <h1>Kafka Rebalancing Dashboard - Engine: ${engineId}</h1>
    
    <div class="status-bar">
        <span id="connection-status" class="status disconnected">Disconnected</span>
        <span>Last Update: <span id="last-update">Never</span></span>
    </div>
    
    <div class="dashboard">
        <div class="card">
            <h3>Current Assignment</h3>
            <div class="metric">
                <span>Assigned Partitions:</span>
                <span class="metric-value" id="partition-count">0</span>
            </div>
            <div class="metric">
                <span>Total in Cluster:</span>
                <span class="metric-value" id="total-partitions">0</span>
            </div>
            <div class="metric">
                <span>Active Engines:</span>
                <span class="metric-value" id="engine-count">0</span>
            </div>
            <div class="metric">
                <span>Distribution Variance:</span>
                <span class="metric-value" id="distribution-variance">0.00</span>
            </div>
        </div>
        
        <div class="card">
            <h3>Rebalancing Metrics</h3>
            <div class="metric">
                <span>Rebalance Events:</span>
                <span class="metric-value" id="rebalance-count">0</span>
            </div>
            <div class="metric">
                <span>Partitions Gained:</span>
                <span class="metric-value" id="partitions-gained">0</span>
            </div>
            <div class="metric">
                <span>Partitions Lost:</span>
                <span class="metric-value" id="partitions-lost">0</span>
            </div>
            <div class="metric">
                <span>Uptime:</span>
                <span class="metric-value" id="uptime">0s</span>
            </div>
        </div>
        
        <div class="card">
            <h3>My Partitions</h3>
            <div id="partition-map" class="partition-map">
                <!-- Partitions will be rendered here -->
            </div>
        </div>
    </div>
    
    <div class="card">
        <h3>Partition Distribution Over Time</h3>
        <div class="chart-container">
            <canvas id="distribution-chart"></canvas>
        </div>
    </div>
    
    <div class="event-log">
        <h3>Recent Events</h3>
        <div id="event-list">
            <!-- Events will be added here -->
        </div>
    </div>
    
    <script>
        const engineId = '${engineId}';
        const wsUrl = 'ws://' + window.location.host + '${wsUrl}';
        let ws = null;
        let chart = null;
        let chartData = {
            labels: [],
            datasets: []
        };
        let maxDataPoints = 50;
        
        // Initialize chart
        function initChart() {
            const ctx = document.getElementById('distribution-chart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Partitions'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true
                        }
                    }
                }
            });
        }
        
        // WebSocket connection
        function connect() {
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function() {
                console.log('Connected to WebSocket');
                document.getElementById('connection-status').className = 'status connected';
                document.getElementById('connection-status').textContent = 'Connected';
                
                // Request initial data
                ws.send('refresh');
            };
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                handleMessage(data);
            };
            
            ws.onclose = function() {
                console.log('Disconnected from WebSocket');
                document.getElementById('connection-status').className = 'status disconnected';
                document.getElementById('connection-status').textContent = 'Disconnected';
                
                // Reconnect after 3 seconds
                setTimeout(connect, 3000);
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }
        
        // Handle incoming messages
        function handleMessage(data) {
            document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
            
            switch(data.type) {
                case 'initial':
                    handleInitialData(data);
                    break;
                case 'rebalance':
                    handleRebalanceEvent(data);
                    break;
                case 'metrics':
                    handleMetricsUpdate(data);
                    break;
                case 'refresh':
                    handleRefresh(data);
                    break;
            }
        }
        
        // Handle initial data
        function handleInitialData(data) {
            updateGlobalState(data.globalState);
            
            // Load recent events
            if (data.recentEvents) {
                data.recentEvents.forEach(event => addEventToLog(event));
            }
        }
        
        // Handle rebalance event
        function handleRebalanceEvent(data) {
            updateGlobalState(data.globalState);
            updateMetrics(data.metrics);
            addEventToLog(data.event);
            updateChart(data);
        }
        
        // Handle metrics update
        function handleMetricsUpdate(data) {
            updateGlobalState(data.globalState);
            
            if (data.engineMetrics && data.engineMetrics[engineId]) {
                updateMetrics(data.engineMetrics[engineId]);
            }
        }
        
        // Handle refresh
        function handleRefresh(data) {
            updateGlobalState(data.globalState);
            if (data.metrics) {
                updateMetrics(data.metrics);
            }
        }
        
        // Update global state display
        function updateGlobalState(state) {
            if (!state) return;
            
            document.getElementById('total-partitions').textContent = state.totalPartitions || 0;
            document.getElementById('engine-count').textContent = state.engineCount || 0;
            document.getElementById('distribution-variance').textContent = 
                (state.distributionStdDev || 0).toFixed(2);
            
            // Update partition count for this engine
            if (state.engines && state.engines[engineId]) {
                document.getElementById('partition-count').textContent = state.engines[engineId];
                updatePartitionMap(state.engines[engineId]);
            }
        }
        
        // Update metrics display
        function updateMetrics(metrics) {
            if (!metrics) return;
            
            document.getElementById('partition-count').textContent = metrics.currentPartitionCount || 0;
            document.getElementById('rebalance-count').textContent = metrics.updateCount || 0;
            document.getElementById('partitions-gained').textContent = metrics.partitionsGained || 0;
            document.getElementById('partitions-lost').textContent = metrics.partitionsLost || 0;
            
            if (metrics.uptimeSeconds) {
                document.getElementById('uptime').textContent = formatDuration(metrics.uptimeSeconds);
            }
        }
        
        // Update partition map visualization
        function updatePartitionMap(count) {
            const container = document.getElementById('partition-map');
            container.innerHTML = '';
            
            for (let i = 0; i < count; i++) {
                const partition = document.createElement('div');
                partition.className = 'partition mine';
                partition.textContent = i;
                container.appendChild(partition);
            }
        }
        
        // Add event to log
        function addEventToLog(event) {
            const eventList = document.getElementById('event-list');
            const eventEl = document.createElement('div');
            eventEl.className = 'event ' + (event.changeType === 'GAIN' ? 'gain' : 
                                           event.changeType === 'LOSS' ? 'loss' : '');
            
            const time = new Date(event.timestamp).toLocaleTimeString();
            eventEl.innerHTML = `
                <strong>${time}</strong> - 
                ${event.engineId}: ${event.previousPartitions} → ${event.newPartitions} partitions
                (${event.change > 0 ? '+' : ''}${event.change})
            `;
            
            eventList.insertBefore(eventEl, eventList.firstChild);
            
            // Keep only last 20 events
            while (eventList.children.length > 20) {
                eventList.removeChild(eventList.lastChild);
            }
        }
        
        // Update chart
        function updateChart(data) {
            if (!chart) return;
            
            const timestamp = new Date(data.timestamp).toLocaleTimeString();
            
            // Add timestamp
            chartData.labels.push(timestamp);
            if (chartData.labels.length > maxDataPoints) {
                chartData.labels.shift();
            }
            
            // Update or create dataset for each engine
            if (data.globalState && data.globalState.engines) {
                Object.entries(data.globalState.engines).forEach(([engine, count]) => {
                    let dataset = chartData.datasets.find(d => d.label === engine);
                    
                    if (!dataset) {
                        dataset = {
                            label: engine,
                            data: [],
                            borderColor: getColorForEngine(engine),
                            backgroundColor: getColorForEngine(engine, 0.1),
                            tension: 0.1
                        };
                        chartData.datasets.push(dataset);
                    }
                    
                    dataset.data.push(count);
                    if (dataset.data.length > maxDataPoints) {
                        dataset.data.shift();
                    }
                });
            }
            
            chart.update('none'); // No animation for real-time updates
        }
        
        // Get color for engine
        function getColorForEngine(engine, alpha = 1) {
            const colors = [
                '#3498db', '#27ae60', '#e74c3c', '#f39c12', 
                '#9b59b6', '#1abc9c', '#34495e', '#e67e22'
            ];
            
            let hash = 0;
            for (let i = 0; i < engine.length; i++) {
                hash = engine.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            const color = colors[Math.abs(hash) % colors.length];
            
            if (alpha === 1) return color;
            
            // Convert hex to rgba
            const hex = color.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // Format duration
        function formatDuration(seconds) {
            if (seconds < 60) return seconds + 's';
            if (seconds < 3600) return Math.floor(seconds / 60) + 'm';
            return Math.floor(seconds / 3600) + 'h ' + Math.floor((seconds % 3600) / 60) + 'm';
        }
        
        // Initialize
        initChart();
        connect();
        
        // Request history after connection
        setTimeout(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send('history:50');
            }
        }, 1000);
    </script>
</body>
</html>